<!doctype html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no">
    
    
    <!--Simple SEO-->

<meta name="description" content="程序员的梦工厂/">


<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->

<title>JMM和底层实现原理 | 小小杰博客</title>

<link rel="alternate" href="/atom.xml" title="小小杰博客" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/css/pages/post.css">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/thirdParty/highlight/github.css">


    <!--script-->



<!--<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>-->



    
    
</head>
</html>
<body id="normal">
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<style>
    header{ top: 71px; position: absolute!important;}
    #container{padding-top: 151px!important;}
</style>
<div style="position:fixed;z-index:9999;left:0;top:0;width:100%;height:70px;background-color:#e0e0e0;color:#396CA5;border-bottom:1px solid #cecece;text-align:center;line-height:70px;white-space: nowrap;overflow: hidden;text-overflow: ellipsis">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<div id="wrap">
    <header style="position: absolute;">
    <div id="site-meta">
        <a href="/" id="logo">
            <h1 class="title">小小杰博客</h1>
        </a>
        
        <h2 class="subtitle">锦绣前程</h2>
        
    </div>
    <ul id="nav">
        
            <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
        
            <li><a href="/2018/12/15/about/"><i class="fa fa-user"></i>关于我</a></li>
        
            <li><a href="/atom.xml"><i class="fa fa-rss"></i>RSS</a></li>
        
        <li id="search"><a href="javascript:void(0)"><i class="fa fa-search"></i>搜索</a></li>
    </ul>
</header>

    <div id="container">
        
<ul id="sidebar">
    
    
<li class="widget notification">
    <i class="fa fa-bell-o"></i>
    <div>
        
<p>学而时习之，不亦乐乎</p>
    </div>
</li>

    
    
<li class="widget widget-normal category">
    <h3 class="fa fa-th widget-title">分类</h3>
    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/工具/"><i class="fa" aria-hidden="true">工具</i></a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/工具/Maven/"><i class="fa" aria-hidden="true">Maven</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/docker/"><i class="fa" aria-hidden="true">docker</i></a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/"><i class="fa" aria-hidden="true">并发编程</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架/"><i class="fa" aria-hidden="true">框架</i></a><span class="category-list-count">10</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/框架/Spring/"><i class="fa" aria-hidden="true">Spring</i></a><span class="category-list-count">10</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息中间件/"><i class="fa" aria-hidden="true">消息中间件</i></a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/消息中间件/Kafka/"><i class="fa" aria-hidden="true">Kafka</i></a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/消息中间件/RabbitMQ/"><i class="fa" aria-hidden="true">RabbitMQ</i></a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link current" href="/categories/随笔/"><i class="fa" aria-hidden="true">随笔</i></a><span class="category-list-count">5</span></li></ul>
</li>


    
    
<li class="widget widget-normal archive">
  <h3 class="fa fa-archive widget-title">时光轴</h3>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/"><i class="fa" aria-hidden="true">四月 2020</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/"><i class="fa" aria-hidden="true">七月 2019</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/"><i class="fa" aria-hidden="true">六月 2019</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/"><i class="fa" aria-hidden="true">三月 2019</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/"><i class="fa" aria-hidden="true">二月 2019</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/"><i class="fa" aria-hidden="true">十二月 2018</i></a><span class="archive-list-count">5</span></li></ul>
</li>


    
    

    
    
<li class="widget widget-normal tags">
  <h3 class="fa fa-tags widget-title">标签云</h3>
  <div class="tagcloud-content">
    
      <a href="/tags/docker/" style="font-size: 0.16rem; color: #4f83b8">docker</a> <a href="/tags/类加载/" style="font-size: 0.14rem; color: #69c">类加载</a> <a href="/tags/索引/" style="font-size: 0.14rem; color: #69c">索引</a> <a href="/tags/jvm/" style="font-size: 0.14rem; color: #69c">jvm</a> <a href="/tags/事务/" style="font-size: 0.14rem; color: #69c">事务</a> <a href="/tags/关于我/" style="font-size: 0.14rem; color: #69c">关于我</a> <a href="/tags/Kafka/" style="font-size: 0.17rem; color: #386da4">Kafka</a> <a href="/tags/Maven/" style="font-size: 0.14rem; color: #69c">Maven</a> <a href="/tags/RabbitMQ/" style="font-size: 0.14rem; color: #69c">RabbitMQ</a> <a href="/tags/Spring/" style="font-size: 0.2rem; color: #0a407c">Spring</a> <a href="/tags/多线程/" style="font-size: 0.18rem; color: #215690">多线程</a>
  </div>
</li>


    
    
<li class="widget widget-normal friends-link">
    <h3 class="fa fa-globe widget-title">友情链接</h3><br>

    
        <a href="http://enjoy.ke.qq.com" class="fa" target="_blank">享学课堂</a>

    
        <a href="http://wuwenliang.net" class="fa" target="_blank">朝·闻·道</a>

    
        <a href="https://pleuvoir.github.io" class="fa" target="_blank">撄而后成</a>

    

</li>


    
</ul>


        <div id="main">
    <article id="post">
        <div id="post-header">

            <h1 id="JMM和底层实现原理">
                
                JMM和底层实现原理
                
            </h1>
            <div class="article-meta">
    
    
    <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
        <span>并发编程</span>
    </span>
    
    
    <span class="fa-wrap">
         <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            多线程
            
        </span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta ">2019/06/20</span>
    </span>
    
    
    
</div>

            
            
        </div>
        
        <div id="post-body">
            <h2 id="JMM基础-计算机原理"><a href="#JMM基础-计算机原理" class="headerlink" title="JMM基础-计算机原理"></a>JMM基础-计算机原理</h2><p>Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java1.5版本对其进行了重构，现在的Java仍沿用了Java1.5的版本。Jmm遇到的问题与现代计算机中遇到的问题是差不多的。</p>
<p>物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。</p>
<p>根据《Jeff Dean在Google全体工程大会的报告》我们可以看到</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn1oitx4j30hv0ap3zg.jpg" alt></p>
<p>计算机在做一些我们平时的基本操作时，需要的响应时间是不一样的。</p>
<p>（以下案例仅做说明，并不代表真实情况。）</p>
<p>如果从内存中读取1M的int型数据由CPU进行累加，耗时要多久？</p>
<p>做个简单的计算，1M的数据，Java里int型为32位，4个字节，共有1024<em>1024/4 = 262144个整数 ，则CPU 计算耗时：262144 </em>0.6 = 157 286 纳秒，而我们知道从内存读取1M数据需要250000纳秒，两者虽然有差距（当然这个差距并不小，十万纳秒的时间足够CPU执行将近二十万条指令了），但是还在一个数量级上。但是，没有任何缓存机制的情况下，意味着每个数都需要从内存中读取，这样加上CPU读取一次内存需要100纳秒，262144个整数从内存读取到CPU加上计算时间一共需要262144*100+250000 = 26 464 400 纳秒，这就存在着数量级上的差异了。</p>
<p>而且现实情况中绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是基本上是无法消除的（无法仅靠寄存器来完成所有运算任务）。早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，cpu的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn1ofwszj30kd09vwiy.jpg" alt></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn1nkpp3j30ji0bidlt.jpg" alt></p>
<p>在计算机系统中，寄存器划是L0级缓存，接着依次是L1，L2，L3（接下来是内存，本地磁盘，远程存储）。越往上的缓存存储空间越小，速度越快，成本也更高；越往下的存储空间越大，速度更慢，成本也更低。从上至下，每一层都可以看做是更下一层的缓存，即：L0寄存器是L1一级缓存的缓存，L1是L2的缓存，依次类推；每一层的数据都是来至它的下一层，所以每一层的数据是下一层的数据的子集。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jn2apo0aj30k00jvq4g.jpg" alt></p>
<p>在现代CPU上，一般来说L0， L1，L2，L3都集成在CPU内部，而L1还分为一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存（Instruction Cache，I-Cache，L1i），分别用于存放数据和执行数据的指令解码。每个核心拥有独立的运算处理单元、控制器、寄存器、L1、L2缓存，然后一个CPU的多个核心共享最后一层CPU缓存L3</p>
<h2 id="物理内存模型带来的问题"><a href="#物理内存模型带来的问题" class="headerlink" title="物理内存模型带来的问题"></a>物理内存模型带来的问题</h2><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p>
<p>现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jn2amfexj30l204kt9c.jpg" alt></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jn2ajky7j30jy0evgo0.jpg" alt></p>
<p>处理器A和处理器B按程序的顺序并行执行内存访问，最终可能得到x=y=0的结果。</p>
<p>处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（步骤A1，B1），然后从内存中读取另一个共享变量（步骤A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（步骤A3，B3）。当以这种时序执行时，程序就可以得到x=y=0的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1→A2，但内存操作实际发生的顺序却是A2→A1。</p>
<p>如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p>
<h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><p>前面我们已经知道，CPU中有好几级高速缓存。但是CPU缓存系统中是以缓存行（cache line）为单位存储的。目前主流的CPU Cache的Cache Line大小都是64Bytes。Cache Line可以简单的理解为CPU Cache中的最小缓存单位，今天的CPU不再是按字节访问内存，而是以64字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存。</p>
<p>一个缓存行可以存储多个变量（存满当前缓存行的字节数）；而CPU对缓存的修改又是以缓存行为最小单位的，在多线程情况下，如果需要修改“共享同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）。</p>
<p>为了避免伪共享，我们可以使用数据填充的方式来避免，即单个数据填充满一个CacheLine。这本质是一种空间换时间的做法。但是这种方式在Java7以后可能失效。</p>
<p>Java8中已经提供了官方的解决方案，Java8中新增了一个注解@sun.misc.Contended。</p>
<p>比如JDK的ConcurrentHashMap中就有使用</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn312ce6j30i602zweg.jpg" alt></p>
<p>加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在jvm启动时设置-XX:-RestrictContended才会生效。</p>
<p>测试代码，参见cn.enjoyedu.ch9. FalseSharing</p>
<p>一个类中，只有一个long类型的变量：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn2znr7yj30e80270sl.jpg" alt></p>
<p>定义一个VolatileLong类型的数组，然后让多个线程同时并发访问这个数组，这时可以想到，在多个线程同时处理数据时，数组中的多个VolatileLong对象可能存在同一个缓存行中。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn2zkmqfj30pl04jgls.jpg" alt></p>
<p>运行后，可以得到运行时间</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jn3mucgnj30qm08bmy1.jpg" alt></p>
<p>花费了39秒多。</p>
<p>我们改用进行了缓存行填充的变量</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jn3mq7vvj310o08rq41.jpg" alt></p>
<p>花费了8.1秒，如果任意注释上下填充行的任何一行，时间表现不稳定，从8秒到20秒都有，但是还是比不填充要快。具体原因目前未知。</p>
<p>再次改用注解标识的变量，同时加入参数-XX:-RestrictContended</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jn3mmd7hj30dv058q2w.jpg" alt></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jn4io346j30rb068gm7.jpg" alt></p>
<p>花费了7.7秒。</p>
<p>由上述的实验结果表明，伪共享确实会影响应用的性能。</p>
<h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个<strong>私有</strong>的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jn4il8k7j30c702rmxa.jpg" alt></p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jn4iiebfj30i307wjur.jpg" alt></p>
<h2 id="Java内存模型带来的问题"><a href="#Java内存模型带来的问题" class="headerlink" title="Java内存模型带来的问题"></a>Java内存模型带来的问题</h2><h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn56masvj30qe0bl753.jpg" alt></p>
<p>左边CPU中运行的线程从主存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2。但这个变更对运行在右边CPU中的线程不可见，因为这个更改还没有flush到主存中。</p>
<p>在多线程的环境下，如果某个线程首次读取共享变量，则首先到主内存中获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量即可。同样如果对该变量执行了修改的操作，则先将新值写入工作内存中，然后再刷新至主内存中。但是什么时候最新的值会被刷新至主内存中是不太确定，一般来说会很快，但具体时间不知。</p>
<p>要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。</p>
<h3 id="竞争问题"><a href="#竞争问题" class="headerlink" title="竞争问题"></a>竞争问题</h3><p>线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jn56iqmkj30q90c5my0.jpg" alt></p>
<p>如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3。然而图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的Obj.count只会增加1次变成2，尽管一共有两次加1操作。 要解决上面的问题我们可以使用java synchronized代码块</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><h4 id="重排序类型"><a href="#重排序类型" class="headerlink" title="重排序类型"></a>重排序类型</h4><p>除了共享内存和工作内存带来的问题，还存在重排序的问题：在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p>
<p>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
<p>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
<p>3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型，上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn56en46j30ma09k0tg.jpg" alt></p>
<p>例如：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn6lclm4j306804vmx8.jpg" alt></p>
<p>很明显，A和C存在数据依赖，B和C也存在数据依赖，而A和B之间不存在数据依赖，如果重排序了A和C或者B和C的执行顺序，程序的执行结果就会被改变。</p>
<p>很明显，不管如何重排序，都必须保证代码在单线程下的运行正确，连单线程下都无法正确，更不用讨论多线程并发的情况，所以就提出了一个as-if-serial的概念。</p>
<h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。（强调一下，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。）但是，如果操作之间不存在数据依赖关系，这些操作依然可能被编译器和处理器重排序。</p>
<p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn6l971oj309d028mx3.jpg" alt> <img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn6l6r2cj309d024dfr.jpg" alt></p>
<p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器可以让我们感觉到：单线程程序看起来是按程序的顺序来执行的。asif-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h4 id="控制依赖性"><a href="#控制依赖性" class="headerlink" title="控制依赖性"></a>控制依赖性</h4><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn79iz6bj30a80a3dfx.jpg" alt></p>
<p>上述代码中，flag变量是个标记，用来标识变量a是否已被写入，在use方法中变量i的赋值依赖if (flag)的判断，这里就叫控制依赖，如果发生了重排序，结果就不对了。</p>
<p>考察代码，我们可以看见，</p>
<p>操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。操作3和操作4则存在所谓<strong>控制依赖关系</strong>。</p>
<p>在程序中，当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当操作3的条件判断为真时，就把该计算结果写入变量i中。猜测执行实质上对操作3和4做了重排序，问题在于这时候，a的值还没被线程A赋值。</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）。</p>
<p>但是对多线程来说就完全不同了：这里假设有两个线程A和B，A首先执行init ()方法，随后B线程接着执行use ()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？答案是：不一定能看到。</p>
<p>让我们先来看看，当操作1和操作2重排序，操作3和操作4重排序时，可能会产生什么效果？操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还没有被线程A写入，这时就会发生错误！</p>
<p>所以在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序，从而让程序按我们预想的流程去执行。</p>
<p>1、保证特定操作的执行顺序。</p>
<p>2、影响某些数据（或则是某条指令的执行结果）的内存可见性。</p>
<p>编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。</p>
<p>Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。</p>
<p>JMM把内存屏障指令分为4类</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn79fxghj30o009i0wk.jpg" alt></p>
<p> StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jn79aeoaj30b70gn0tz.jpg" alt></p>
<p>JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得多线程在这两个时间点按某种顺序执行。</p>
<p>临界区内的代码则可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>回想一下，为啥线程安全的单例模式中一般的双重检查不能保证真正的线程安全？</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>在Java 规范提案中为让大家理解内存可见性的这个概念，提出了happens-before的概念来阐述操作之间的内存可见性。对应Java程序员来说，理解happens-before是理解JMM的关键。</p>
<p>JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证<strong>正确同步</strong>的多线程程序的执行结果不被改变。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系 。 </p>
<p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）</p>
<h4 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h4><p>上面的定义看起来很矛盾，其实它是站在不同的角度来说的。</p>
<p>1）站在Java程序员的角度来说：JMM保证，如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p>
<p>2）站在编译器和处理器的角度来说：JMM允许，两个操作之间存在happens-before关系，<strong>不要求</strong> <strong>Java</strong> <strong>平台的具体实现必须要按照</strong> <strong>happens-before</strong> <strong>关系指定的顺序来执行</strong>。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序是允许的。</p>
<p>回顾我们前面存在数据依赖性的代码：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn7vsvp3j305k03imx7.jpg" alt></p>
<p>站在我们Java程序员的角度：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn7vpyelj305u038t8t.jpg" alt></p>
<p>但是仔细考察，2、3是必需的，而1并不是必需的，因此JMM对这三个happens-before关系的处理就分为两类：</p>
<p>1.会改变程序执行结果的重排序</p>
<p>2.不会改变程序执行结果的重排序</p>
<p>JMM对这两种不同性质的重排序，采用了不同的策略，如下：</p>
<p>1.对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序；</p>
<p>2.对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求。</p>
<p>于是，站在我们程序员的角度，看起来这个三个操作满足了happens-before关系，而站在编译器和处理器的角度，进行了重排序，而排序后的执行结果，也是满足happens-before关系的。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn7vmzvwj30jq0lhjw2.jpg" alt></p>
<h4 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h4><p>JMM为我们提供了以下的Happens-Before规则：</p>
<p>1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p>
<p>2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</p>
<p>3）volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p>
<p>4）传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
<p>5）start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</p>
<p>6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 </p>
<p>7 ）线程中断规则:对线程interrupt方法的调用happens-before于被中断线程的代码检测到中断事件的发生。</p>
<h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><h4 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h4><p>可以把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jn8c6btzj30k109v3ys.jpg" alt></p>
<p>可以看成</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn8c2bpkj30np0b5aaj.jpg" alt></p>
<p>所以volatile变量自身具有下列特性：</p>
<p>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</p>
<h4 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h4><p>内存语义：可以简单理解为 volatile，synchronize，atomic，lock 之类的在 JVM 中的内存方面实现原则。</p>
<p>volatile写的内存语义如下：<br> 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。 </p>
<p>volatile读的内存语义如下：<br> 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 </p>
<p>所以对于代码</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jn8by9pjj30bw0ba74g.jpg" alt></p>
<p>如果我们将<strong>flag</strong>变量以<strong>volatile</strong>关键字修饰，那么实际上：线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值都被刷新到主内存中。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn8u4behj30h00btmxh.jpg" alt></p>
<p>在读flag变量后，本地内存B包含的值已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值变成一致。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jn8u0llwj30j70cpwez.jpg" alt></p>
<p>如果我们把volatile写和volatile读两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p>
<h4 id="为何volatile不是线程安全的"><a href="#为何volatile不是线程安全的" class="headerlink" title="为何volatile不是线程安全的"></a>为何volatile不是线程安全的</h4><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jn8tw4kmj30le0af767.jpg" alt></p>
<h4 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h4><h5 id="volatile重排序规则表"><a href="#volatile重排序规则表" class="headerlink" title="volatile重排序规则表"></a>volatile重排序规则表</h5><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn9anw36j30mx06j0th.jpg" alt></p>
<p>总结起来就是：</p>
<p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p>
<p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p>
<p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p>
<h5 id="volatile的内存屏障"><a href="#volatile的内存屏障" class="headerlink" title="volatile的内存屏障"></a>volatile的内存屏障</h5><p>在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序问题。</p>
<h6 id="volatile写"><a href="#volatile写" class="headerlink" title="volatile写"></a>volatile写</h6><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jn9akxlpj30au0bc74z.jpg" alt></p>
<p>storestore屏障：对于这样的语句store1; storestore; store2，在store2及后续写入操作执行前，保证store1的写入操作对其它处理器可见。(也就是说如果出现storestore屏障，那么store1指令一定会在store2之前执行，CPU不会store1与store2进行重排序)</p>
<p>storeload屏障：对于这样的语句store1; storeload; load2，在load2及后续所有读取操作执行前，保证store1的写入对所有处理器可见。(也就是说如果出现storeload屏障，那么store1指令一定会在load2之前执行,CPU不会对store1与load2进行重排序)</p>
<h6 id="volatile读"><a href="#volatile读" class="headerlink" title="volatile读"></a>volatile读</h6><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jn9ahdu4j30am0blgmb.jpg" alt></p>
<p>在每个volatile读操作的后面插入一个LoadLoad屏障。在每个volatile读操作的后面插入一个loadstore屏障。</p>
<p>  loadload屏障：对于这样的语句load1; loadload; load2，在load2及后续读取操作要读取的数据被访问前，保证load1要读取的数据被读取完毕。（也就是说，如果出现loadload屏障，那么load1指令一定会在load2之前执行，CPU不会对load1与load2进行重排序） </p>
<p>  loadstore屏障：对于这样的语句load1; loadstore; store2，在store2及后续写入操作被刷出前，保证load1要读取的数据被读取完毕。（也就是说，如果出现loadstore屏障，那么load1指令一定会在store2之前执行，CPU不会对load1与store2进行重排序）</p>
<h3 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h3><p>通过对OpenJDK中的unsafe.cpp源码的分析，会发现被volatile关键字修饰的变量会存在一个“lock:”的前缀。</p>
<p>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。</p>
<p>同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</p>
<p>1、 在具体的执行上，它先对总线和缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的脏数据全部刷新回主内存。在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放。</p>
<h2 id="final的内存语义"><a href="#final的内存语义" class="headerlink" title="final的内存语义"></a>final的内存语义</h2><p>在构造线程的类时，我们有种方式就是让类中所有的成员变量都不可变，利用的就是final关键字，那么这个final为何可以做到呢？重排序这种优化动作对构造方法，一样也是存在的。这就说明，一个成员变量加了final关键字后，JMM一定是做了相关处理的。</p>
<h3 id="final的两个重排序规则"><a href="#final的两个重排序规则" class="headerlink" title="final的两个重排序规则"></a>final的两个重排序规则</h3><p>对应final域，编译器和处理器需要遵守两个重排序规则。我们以代码cn.enjoyedu.ch9.semantics. FinalMemory来说明</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jna6qfhkj30dp0alt93.jpg" alt></p>
<p>我们假设一个线程A执行writer方法，随后另一个线程B执行reader方法。</p>
<p>1、在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<p>看write()方法，只包含一行代码 <em>obj</em> = <strong>new</strong> FinalMemory();。这一行代码包含两个步骤：</p>
<p>构造一个FinalMemory类型的对象。</p>
<p>把这个对象的引用赋值给引用变量obj。</p>
<p>假设线程B读对象引用（FinalMemory object = obj）与读对象的成员域之间（int a = object.i;int b = object.j）没有重排序，下面的图是一种可能的执行时序：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jna6n40yj30h40gwjt7.jpg" alt></p>
<p>从上面可能的时序图中我们可以看到，写普通域被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限制”到了构造函数之内，读线程B正确读取了final变量初始化之后的值。</p>
<p>总结：写final域的重排序规则可以确保在对象引用为任意线程可见之前，对象的final域已经被正常的初始化了，而普通域不具有这样的保证。</p>
<p>2、初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序</p>
<p>在一个线程中，<strong>初次读对象引用与初次读该对象包含的</strong> <strong>final</strong> <strong>域</strong>，JMM禁止处理器重排序这两个操作。<strong>编译器会在读</strong> <strong>final</strong> <strong>域操作的前面插入一个</strong> <strong>LoadLoad</strong> <strong>屏障</strong>。</p>
<p>reader()方法包含3个步骤：</p>
<p>初次读引用变量obj</p>
<p>初次读引用变量obj指向对象的普通域 i</p>
<p>初次读引用变量obj指向对象的final域 j</p>
<p> 我们假设写线程A没有发生任何重排序，则下图是一种可能的时序：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jna6ib52j309i07nq31.jpg" alt></p>
<p>读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被线程A写入，所以上面的是一个错误的读取操作。但是读final域的重排序规则把读对象final域的操作“限定”在读对象引用之后，该final域已经被A线程初始化了，是一个正确的读取操作。</p>
<p>总结：读final域的重排序规则可以确保在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</p>
<h3 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h3><p>我们以代码cn.enjoyedu.ch9.semantics. FinalRefMemory来说明</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jnazkxp3j30i10fs759.jpg" alt></p>
<p>在上面的代码中，final域是一个引用类型，它引用了一个int类型的数组，对于引用类型，写final域的重排序规则对编译器和处理器增加了一下的约束：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<p>我们假设线程A先执行write0操作，执行完后线程B执行write1操作，执行完后线程C执行reader操作，下图是一种可能的执行时序：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jnazaq8hj30gp0hp765.jpg" alt></p>
<p>1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看得到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步（lock或volatile）来确保内存可见性。</p>
<h3 id="final引用不能从构造函数内逃逸"><a href="#final引用不能从构造函数内逃逸" class="headerlink" title="final引用不能从构造函数内逃逸"></a>final引用不能从构造函数内逃逸</h3><p>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中逃逸。</p>
<p> 我们以cn.enjoyedu.ch9.semantics. FinalEscape为例来说明</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jnaz4ujyj30ct0ciaag.jpg" alt></p>
<p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jnbljlajj30o80jx76l.jpg" alt></p>
<p>因此在构造函数返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被初始化。</p>
<h3 id="final语义的实现"><a href="#final语义的实现" class="headerlink" title="final语义的实现"></a>final语义的实现</h3><p>会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。</p>
<p>读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障</p>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</p>
<p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。 </p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4jnblfr4uj30ld071gmv.jpg" alt></p>
<p>如果我们回顾第一章的VolatileCase，我们知道，为了让子线程可以及时看到<em>ready</em>变量的修改，我们需要将ready变量以volatile来修饰。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jnblbvuwj30ln0cpaau.jpg" alt></p>
<p>但是，当我们将程序做如下改造</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jnc6f0n2j30hy0c90tj.jpg" alt></p>
<p>我们可以看见子线程同样可以中止，为何？我们观察System.out.println的实现，</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jnc6b2g3j309203ejr9.jpg" alt></p>
<p>结合前面锁的内存语义，我们可以知道，当进入<strong>synchronized</strong>语句块时，子线程会被强制从主内存中读取共享变量，其中就包括了ready变量，所以子线程同样中止了。</p>
<h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><p>Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<p>对同步块，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p>
<p>对同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</p>
<p>JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<p>synchronized使用的锁是存放在Java对象头里面，</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jnc66d26j30l303at9f.jpg" alt></p>
<p>具体位置是对象头里面的MarkWord，MarkWord里默认数据是存储对象的HashCode等信息，</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jncslqshj30l101twer.jpg" alt></p>
<p>但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jncsiq68j30g7075wer.jpg" alt></p>
<h2 id="了解各种锁"><a href="#了解各种锁" class="headerlink" title="了解各种锁"></a>了解各种锁</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>但是线程自旋是需要消耗CPU的，说白了就是让CPU在做无用功，线程不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h4 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h4><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着XX不XX，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。</p>
<h4 id="自旋锁时间阈值"><a href="#自旋锁时间阈值" class="headerlink" title="自旋锁时间阈值"></a>自旋锁时间阈值</h4><p>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋次数很重要</p>
<p>JVM对于自旋次数的选择，jdk1.5默认为10次，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p>
<p>JDK1.6中-XX:+UseSpinning开启自旋锁； JDK1.7后，去掉此参数，由jvm控制；</p>
<h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>一共有四种状态，<strong>无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态</strong>，它会随着竞争情况逐渐升级。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。</p>
<p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。</p>
<p>偏向锁获取过程：</p>
<p>步骤1、 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</p>
<p>步骤2、 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</p>
<p>步骤3、 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</p>
<p>步骤4、 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</p>
<p>步骤5、 执行同步代码。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jncsexotj30ku0octdm.jpg" alt></p>
<p>偏向锁的释放：</p>
<p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁的适用场景</p>
<p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； </p>
<p>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。</p>
<p>jvm开启/关闭偏向锁</p>
<p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</p>
<p>关闭偏向锁：-XX:-UseBiasedLocking</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p>
<p>轻量级锁的加锁过程：</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态且不允许进行偏向（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态</p>
<p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jndhqd1cj30mg0lcwke.jpg" alt></p>
<h3 id="不同锁的比较"><a href="#不同锁的比较" class="headerlink" title="不同锁的比较"></a>不同锁的比较</h3><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4jndhkklvj30hc0audgk.jpg" alt></p>
<h3 id="JDK对锁的更多优化措施"><a href="#JDK对锁的更多优化措施" class="headerlink" title="JDK对锁的更多优化措施"></a>JDK对锁的更多优化措施</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行优化：</p>
<p>同步消除synchronization Elimination，如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。</p>
<h4 id="锁消除和粗化"><a href="#锁消除和粗化" class="headerlink" title="锁消除和粗化"></a>锁消除和粗化</h4><p>锁消除：虚拟机的运行时编译器在运行时如果检测到一些要求同步的代码上不可能发生共享数据竞争，则会去掉这些锁。</p>
<p>锁粗化：将临近的代码块用同一个锁合并起来。</p>
<p>消除无意义的锁获取和释放，可以提高程序运行性能。</p>

        </div>
        <div id="post-footer">
            <div class="avatar">
                <img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4jcpbkpo7j30u01407wj.jpg" alt="avatar">
                
                
                <a href="javascript:void(0)" class="donate fa">赠我一杯 &#128536;</a>
                
            </div>
            <ul class="author-profile-section">
                <li>
                  
                  Author:
                  
                    
                    <a href="/about.html">lill</a>
                </li>
                
                <li>Published Date: <span>2019-06-20  23:01:24</span></li>
                
                <li>Updated Date: <span>2020-03-29  19:28:31</span></li>
                
                <li class="post-category">
                    Categories:
                    
                    <a href="/categories/并发编程/">并发编程</a>
                    
                </li>
                <li class="post-tags">
                    Tags:
                    
                    <a href="/tags/多线程/">多线程</a>
                    
                </li>
                
                <li> License: <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">
知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议（CC BY-NC-ND 3.0）
</a></li>
                
            </ul>
            <div id="donate-wrap">
                
                
                
                <img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4j3v2hrrjj30a00fk750.jpg" alt="支付宝付款" class="donate-img">
                
                <img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4jc3z12itj30h90no0tp.jpg" alt="微信付款" class="donate-img">
                
                
            </div>
        </div>
    </article>
    <div class="article-nav">
        
        <a href="/2019/06/20/thread-8/" class="pre-post fa fa-caret-left">Java8新增的并发</a>
        
        
        <a href="/2019/06/20/thread-6/" class="next-post fa">并发安全</a>
        
    </div>
    
    <div id="comments">
        

<script>
  gitment.render(document.getElementById("comments"));
</script>



    </div>
    
</div>


    </div>
    <footer id="footer">
    
    <div class="social">
        
        <a href="https://github.com/EllenJack/ellenjack.github.io.git" class="fa fa-free-code-camp" target="_blank" title="freecodecamp"></a>
        
        <a href="https://github.com/EllenJack/ellenjack.github.io.git" class="fa fa-github" target="_blank" title="Follow me~"></a>
        
    </div>
    
    <div>
        
        <a href="/" class="copyright-links">lill</a>&copy;2015 - 2020.All Rights
        Reserved.
    </div>
    <p>Powered by <a href="https://hexo.io" class="copyright-links" target="_blank">Hexo</a> | Theme by <a href="https://github.com/GeekaholicLin" class="copyright-links" target="_blank">GeekaholicLin</a>
    </p>
    
</footer>

</div>
    <ul id="tools">
    <li class="totop-btn fa fa-angle-up"></li>
    <li class="exchange-btn fa fa-exchange"></li>
  
    <li class="toc-btn fa fa-list-ul"></li>
    
    

    
</ul>
<p id="process"></p>
<div id="search-overlay">
    <div class="search-area-wrap">
        <div id="search-area">
            <div class="input-wrap focus">
                <i class="fa fa-search" aria-hidden="true"></i>
                <input id="search-input" autofocus autocomplete="off" type="text" placeholder="search this website...">
            </div>
            <ul id="search-result">
                <li class="load-first"><i class="fa fa-spinner fa-pulse"></i></li>
            </ul>
        </div>
    </div>
</div>

    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM基础-计算机原理"><span class="toc-number">1.</span> <span class="toc-text">JMM基础-计算机原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理内存模型带来的问题"><span class="toc-number">2.</span> <span class="toc-text">物理内存模型带来的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#伪共享"><span class="toc-number">3.</span> <span class="toc-text">伪共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型（JMM）"><span class="toc-number">4.</span> <span class="toc-text">Java内存模型（JMM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java内存模型带来的问题"><span class="toc-number">5.</span> <span class="toc-text">Java内存模型带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性问题"><span class="toc-number">5.1.</span> <span class="toc-text">可见性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#竞争问题"><span class="toc-number">5.2.</span> <span class="toc-text">竞争问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重排序"><span class="toc-number">5.3.</span> <span class="toc-text">重排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重排序类型"><span class="toc-number">5.3.1.</span> <span class="toc-text">重排序类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据依赖性"><span class="toc-number">5.3.2.</span> <span class="toc-text">数据依赖性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#as-if-serial"><span class="toc-number">5.3.3.</span> <span class="toc-text">as-if-serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#控制依赖性"><span class="toc-number">5.3.4.</span> <span class="toc-text">控制依赖性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存屏障"><span class="toc-number">5.4.</span> <span class="toc-text">内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临界区"><span class="toc-number">5.5.</span> <span class="toc-text">临界区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#happens-before"><span class="toc-number">6.</span> <span class="toc-text">happens-before</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义"><span class="toc-number">6.0.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加深理解"><span class="toc-number">6.0.2.</span> <span class="toc-text">加深理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Happens-Before规则"><span class="toc-number">6.0.3.</span> <span class="toc-text">Happens-Before规则</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile详解"><span class="toc-number">7.</span> <span class="toc-text">volatile详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile特性"><span class="toc-number">7.0.1.</span> <span class="toc-text">volatile特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile的内存语义"><span class="toc-number">7.0.2.</span> <span class="toc-text">volatile的内存语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为何volatile不是线程安全的"><span class="toc-number">7.0.3.</span> <span class="toc-text">为何volatile不是线程安全的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile内存语义的实现"><span class="toc-number">7.0.4.</span> <span class="toc-text">volatile内存语义的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#volatile重排序规则表"><span class="toc-number">7.0.4.1.</span> <span class="toc-text">volatile重排序规则表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#volatile的内存屏障"><span class="toc-number">7.0.4.2.</span> <span class="toc-text">volatile的内存屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#volatile写"><span class="toc-number">7.0.4.2.1.</span> <span class="toc-text">volatile写</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#volatile读"><span class="toc-number">7.0.4.2.2.</span> <span class="toc-text">volatile读</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile的实现原理"><span class="toc-number">7.1.</span> <span class="toc-text">volatile的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final的内存语义"><span class="toc-number">8.</span> <span class="toc-text">final的内存语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final的两个重排序规则"><span class="toc-number">8.1.</span> <span class="toc-text">final的两个重排序规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final域为引用类型"><span class="toc-number">8.2.</span> <span class="toc-text">final域为引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final引用不能从构造函数内逃逸"><span class="toc-number">8.3.</span> <span class="toc-text">final引用不能从构造函数内逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final语义的实现"><span class="toc-number">8.4.</span> <span class="toc-text">final语义的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的内存语义"><span class="toc-number">9.</span> <span class="toc-text">锁的内存语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized的实现原理"><span class="toc-number">10.</span> <span class="toc-text">synchronized的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解各种锁"><span class="toc-number">11.</span> <span class="toc-text">了解各种锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自旋锁"><span class="toc-number">11.1.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理"><span class="toc-number">11.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋锁的优缺点"><span class="toc-number">11.1.2.</span> <span class="toc-text">自旋锁的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋锁时间阈值"><span class="toc-number">11.1.3.</span> <span class="toc-text">自旋锁时间阈值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的状态"><span class="toc-number">11.2.</span> <span class="toc-text">锁的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏向锁"><span class="toc-number">11.3.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轻量级锁"><span class="toc-number">11.4.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同锁的比较"><span class="toc-number">11.5.</span> <span class="toc-text">不同锁的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK对锁的更多优化措施"><span class="toc-number">11.6.</span> <span class="toc-text">JDK对锁的更多优化措施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#逃逸分析"><span class="toc-number">11.6.1.</span> <span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁消除和粗化"><span class="toc-number">11.6.2.</span> <span class="toc-text">锁消除和粗化</span></a></li></ol></li></ol></li>




<script src="/js/search.js"></script>
<script type="text/javascript">
    //theme config datas
    var copyrightObj = {};
    copyrightObj.enable = 'true';
    copyrightObj.triggerCopyLength = '200';
    copyrightObj.appendText = '商业转载请联系作者获得授权,非商业转载请注明出处 © example';
    var leancloudObj = {};
    leancloudObj.enable = 'false';
    leancloudObj.className = 'BlogCounter';
    leancloudObj.limits = '10';
</script>
<script type="text/javascript">
    var search = {};
    var search_path = "search.xml";
    if (!search_path) {
        search_path = "search.xml";
    }
    search.path = "/" + search_path;
    search.func =  _ajax.init();
</script>
<script src="/js/app.js"></script>


</body>
</html>